# 약 복용 시간 추천 서비스 - 코드 아키텍처

## 목차

- [1. 개요](#1-개요)
- [2. 기술 스택](#2-기술-스택)
- [3. 시스템 아키텍처](#3-시스템-아키텍처)
- [4. 프로젝트 구조](#4-프로젝트-구조)
- [5. 데이터베이스 설계](#5-데이터베이스-설계)
- [6. API 설계](#6-api-설계)
- [7. 인증 및 보안](#7-인증-및-보안)
- [8. 상태 관리](#8-상태-관리)
- [9. 스타일링 시스템](#9-스타일링-시스템)
- [10. 배포 전략](#10-배포-전략)
- [11. 성능 최적화](#11-성능-최적화)
- [12. 개발 환경 설정](#12-개발-환경-설정)
- [13. 개발 워크플로우](#13-개발-워크플로우)
- [14. 트러블슈팅](#14-트러블슈팅)

---

## 1. 개요

### 1.1 프로젝트 소개

본 문서는 **약 복용 시간 추천 서비스**의 기술적 구현을 위한 종합 아키텍처 가이드입니다. 생체리듬 기반 복용 시간 추천, 약물 정보 제공, 개인화된 시간표 관리 등의 핵심 기능을 제공하는 웹 애플리케이션을 구축합니다.

### 1.2 핵심 목표

- **최신 기술 스택**: 2026년 기준 최신 안정화 버전 사용
- **Vercel 최적화**: Vercel 플랫폼에 최적화된 배포 구조
- **확장 가능성**: 향후 기능 추가가 용이한 모듈화 구조
- **접근성**: 전 연령층이 사용 가능한 인터페이스
- **보안**: 의료 정보 보호를 위한 철저한 보안 체계

### 1.3 개발 철학

- **사용자 중심**: 개발 경험이 없는 사용자도 이해할 수 있는 문서화
- **모범 사례**: 업계 표준 및 best practice 적용
- **유지보수성**: 명확한 코드 구조와 주석
- **성능 우선**: 빠른 로딩과 반응성

---

## 2. 기술 스택

### 2.1 Core Technologies (2026 최신 안정화 버전)

#### Frontend Framework
**Next.js 15.5.9**
- React 19 완벽 지원
- Turbopack 안정화 (빠른 빌드)
- App Router 기반 (파일 시스템 라우팅)
- Server Components & Client Components 최적 활용
- 선택 이유: SEO 최적화, 성능, Vercel 네이티브 지원

#### UI Library
**React 19.2.3**
- Actions & Form 통합
- 향상된 Hydration
- `use` API 지원
- 선택 이유: 최신 기능, 성능 개선, 커뮤니티 지원

#### Programming Language
**TypeScript 5.9**
- 강력한 타입 안전성
- 최신 ECMAScript 기능
- 코드 자동완성 및 리팩토링 지원
- 선택 이유: 런타임 에러 방지, 개발 생산성 향상

#### Database ORM
**Prisma 7.2.0**
- Type-safe 데이터베이스 쿼리
- 마이그레이션 관리
- 자동 타입 생성
- 선택 이유: TypeScript 통합, 직관적 API, Vercel Postgres 최적화

#### Database
**Vercel Postgres (Neon Serverless)**
- Serverless PostgreSQL
- 자동 스케일링
- Edge 최적화
- 선택 이유: Vercel 네이티브 통합, 비용 효율성, 관리 편의성

#### Styling
**Tailwind CSS 4.1.18**
- Utility-first CSS
- 반응형 디자인
- 커스텀 디자인 시스템
- 선택 이유: 빠른 개발, 일관성, 작은 번들 크기

#### State Management
**Zustand v5**
- 간단한 API
- 최소 보일러플레이트
- TypeScript 완벽 지원
- 선택 이유: Redux보다 단순, Context API보다 성능 우수

#### Authentication
**NextAuth.js 4.24.13**
- 다양한 OAuth 제공자
- JWT/Session 기반 인증
- Edge 호환
- 선택 이유: Next.js 최적화, 보안성, 쉬운 설정

### 2.2 Additional Libraries & Tools

#### Form Management
- **React Hook Form 7.x**: 폼 상태 관리, 유효성 검증
- **Zod 3.x**: TypeScript 스키마 검증

#### Date & Time
- **date-fns 3.x**: 날짜 처리 (가벼움)
- **date-fns-tz**: 시간대 처리

#### HTTP Client
- **Axios 1.x**: HTTP 요청 (식약처 API 연동)
- **SWR 2.x**: 데이터 페칭, 캐싱, 재검증

#### UI Components
- **Radix UI**: 접근성 우수한 headless 컴포넌트
- **Heroicons**: 아이콘 라이브러리

#### Development Tools
- **ESLint**: 코드 품질 검사
- **Prettier**: 코드 포매팅
- **Husky**: Git hooks 관리
- **lint-staged**: 커밋 전 린팅

### 2.3 External APIs

#### 식품의약품안전처 공공데이터 API
- **의약품 허가 정보 조회**: 약품명, 성분, 제조사 등
- **API URL**: `http://apis.data.go.kr/1471000/DrugPrdtPrmsnInfoService07/getDrugPrdtPrmsnInq07`
- **응답 형식**: JSON/XML
- **인증**: ServiceKey 필요

---

## 3. 시스템 아키텍처

### 3.1 전체 시스템 다이어그램

```mermaid
graph TB
    subgraph Client[클라이언트 Layer]
        Browser[웹 브라우저]
        Mobile[모바일 브라우저]
    end
    
    subgraph Vercel[Vercel Platform]
        Edge[Edge Runtime]
        NextJS[Next.js App]
        ServerComponents[Server Components]
        APIRoutes[API Routes]
    end
    
    subgraph Data[데이터 Layer]
        NeonDB[(Vercel Postgres/Neon)]
        ExternalAPI[식약처 API]
    end
    
    subgraph Auth[인증 Layer]
        NextAuth[NextAuth.js]
        Session[Session Storage]
    end
    
    Browser --> Edge
    Mobile --> Edge
    Edge --> NextJS
    NextJS --> ServerComponents
    NextJS --> APIRoutes
    APIRoutes --> NeonDB
    APIRoutes --> ExternalAPI
    NextAuth --> Session
    NextAuth --> NeonDB
    ServerComponents --> NeonDB
```

### 3.2 데이터 플로우

```mermaid
sequenceDiagram
    participant User as 사용자
    participant Client as 클라이언트
    participant Server as Next.js Server
    participant DB as Database
    participant ExtAPI as 식약처 API
    
    User->>Client: 약 검색 요청
    Client->>Server: API 호출 (/api/medicines/search)
    Server->>ExtAPI: 약품 정보 요청
    ExtAPI-->>Server: 약품 데이터 반환
    Server->>DB: 검색 기록 저장
    Server-->>Client: 약품 정보 반환
    Client-->>User: 검색 결과 표시
    
    User->>Client: 복용 시간 추천 요청
    Client->>Server: API 호출 (/api/recommendations)
    Server->>DB: 사용자 생활패턴 조회
    Server->>DB: 약물 특성 조회
    Server-->>Client: 추천 시간 반환
    Client-->>User: 추천 결과 표시
```

### 3.3 Layer Architecture

```
┌─────────────────────────────────────┐
│     Presentation Layer              │
│  (React Components, Pages, UI)      │
├─────────────────────────────────────┤
│     Application Layer               │
│  (Business Logic, Services)         │
├─────────────────────────────────────┤
│     API Layer                       │
│  (REST Endpoints, Route Handlers)   │
├─────────────────────────────────────┤
│     Data Access Layer               │
│  (Prisma ORM, Database Queries)     │
├─────────────────────────────────────┤
│     Infrastructure Layer            │
│  (Database, External APIs, Auth)    │
└─────────────────────────────────────┘
```

---

## 4. 프로젝트 구조

### 4.1 디렉토리 구조

```
meditime/
├── .github/                      # GitHub 설정
│   └── workflows/                # CI/CD 워크플로우
│       └── ci.yml
├── .husky/                       # Git hooks
│   ├── pre-commit
│   └── pre-push
├── public/                       # 정적 파일
│   ├── images/                   # 이미지
│   ├── icons/                    # 아이콘
│   └── fonts/                    # 폰트
├── prisma/                       # Prisma 스키마 및 마이그레이션
│   ├── schema.prisma             # 데이터베이스 스키마
│   ├── migrations/               # 마이그레이션 파일
│   └── seed.ts                   # 시드 데이터
├── src/                          # 소스 코드
│   ├── app/                      # Next.js App Router
│   │   ├── (auth)/               # 인증 관련 페이지
│   │   │   ├── login/
│   │   │   │   └── page.tsx
│   │   │   └── register/
│   │   │       └── page.tsx
│   │   ├── (main)/               # 메인 애플리케이션
│   │   │   ├── dashboard/
│   │   │   │   └── page.tsx
│   │   │   ├── medicines/
│   │   │   │   ├── page.tsx
│   │   │   │   ├── [id]/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── search/
│   │   │   │       └── page.tsx
│   │   │   ├── schedule/
│   │   │   │   └── page.tsx
│   │   │   ├── education/
│   │   │   │   └── page.tsx
│   │   │   └── settings/
│   │   │       └── page.tsx
│   │   ├── api/                  # API Routes
│   │   │   ├── auth/             # 인증 API
│   │   │   │   └── [...nextauth]/
│   │   │   │       └── route.ts
│   │   │   ├── medicines/        # 약물 API
│   │   │   │   ├── search/
│   │   │   │   │   └── route.ts
│   │   │   │   ├── [id]/
│   │   │   │   │   └── route.ts
│   │   │   │   └── external/     # 외부 API 프록시
│   │   │   │       └── route.ts
│   │   │   ├── recommendations/  # 추천 API
│   │   │   │   └── route.ts
│   │   │   ├── user-medicines/   # 사용자 약물 API
│   │   │   │   └── route.ts
│   │   │   ├── schedule/         # 스케줄 API
│   │   │   │   └── route.ts
│   │   │   └── patterns/         # 생활패턴 API
│   │   │       └── route.ts
│   │   ├── layout.tsx            # 루트 레이아웃
│   │   ├── page.tsx              # 랜딩 페이지
│   │   └── globals.css           # 글로벌 스타일
│   ├── components/               # React 컴포넌트
│   │   ├── ui/                   # UI 기본 컴포넌트
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Card.tsx
│   │   │   ├── Modal.tsx
│   │   │   ├── Alert.tsx
│   │   │   └── index.ts
│   │   ├── layout/               # 레이아웃 컴포넌트
│   │   │   ├── Header.tsx
│   │   │   ├── Footer.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   └── Navigation.tsx
│   │   ├── medicine/             # 약물 관련 컴포넌트
│   │   │   ├── MedicineCard.tsx
│   │   │   ├── MedicineList.tsx
│   │   │   ├── MedicineSearch.tsx
│   │   │   └── MedicineDetail.tsx
│   │   ├── schedule/             # 스케줄 관련 컴포넌트
│   │   │   ├── Timeline.tsx
│   │   │   ├── ScheduleList.tsx
│   │   │   └── TimeSlot.tsx
│   │   ├── recommendation/       # 추천 관련 컴포넌트
│   │   │   ├── RecommendationCard.tsx
│   │   │   └── TimingExplanation.tsx
│   │   └── auth/                 # 인증 관련 컴포넌트
│   │       ├── LoginForm.tsx
│   │       └── RegisterForm.tsx
│   ├── lib/                      # 유틸리티 및 설정
│   │   ├── prisma.ts             # Prisma 클라이언트
│   │   ├── auth.ts               # 인증 설정
│   │   ├── utils.ts              # 유틸 함수
│   │   ├── constants.ts          # 상수
│   │   └── validators.ts         # 유효성 검증
│   ├── services/                 # 비즈니스 로직
│   │   ├── medicineService.ts    # 약물 서비스
│   │   ├── recommendationService.ts  # 추천 서비스
│   │   ├── scheduleService.ts    # 스케줄 서비스
│   │   ├── externalApiService.ts # 외부 API 서비스
│   │   └── userService.ts        # 사용자 서비스
│   ├── store/                    # Zustand 스토어
│   │   ├── authStore.ts          # 인증 상태
│   │   ├── medicineStore.ts      # 약물 상태
│   │   ├── scheduleStore.ts      # 스케줄 상태
│   │   └── uiStore.ts            # UI 상태
│   ├── hooks/                    # 커스텀 훅
│   │   ├── useMedicine.ts
│   │   ├── useSchedule.ts
│   │   ├── useRecommendation.ts
│   │   └── useLifePattern.ts
│   ├── types/                    # TypeScript 타입
│   │   ├── medicine.ts
│   │   ├── user.ts
│   │   ├── schedule.ts
│   │   ├── recommendation.ts
│   │   └── index.ts
│   └── styles/                   # 스타일 관련
│       └── tailwind-config.ts    # Tailwind 설정
├── tests/                        # 테스트
│   ├── unit/                     # 유닛 테스트
│   ├── integration/              # 통합 테스트
│   └── e2e/                      # E2E 테스트
├── .env.local                    # 환경 변수 (로컬)
├── .env.example                  # 환경 변수 예시
├── .eslintrc.json                # ESLint 설정
├── .prettierrc                   # Prettier 설정
├── next.config.js                # Next.js 설정
├── tailwind.config.ts            # Tailwind 설정
├── tsconfig.json                 # TypeScript 설정
├── package.json                  # 패키지 정의
└── README.md                     # 프로젝트 문서
```

### 4.2 파일 명명 규칙

#### 컴포넌트
- **PascalCase**: `Button.tsx`, `MedicineCard.tsx`
- **폴더와 동일한 이름**: `Button/Button.tsx`

#### 페이지
- **kebab-case**: `user-medicines/page.tsx`
- **동적 라우트**: `[id]/page.tsx`, `[...slug]/page.tsx`

#### 유틸리티 & 서비스
- **camelCase**: `medicineService.ts`, `formatDate.ts`

#### 타입
- **PascalCase (인터페이스/타입)**: `Medicine`, `UserProfile`
- **파일명은 camelCase**: `medicine.ts`, `user.ts`

#### 상수
- **UPPER_SNAKE_CASE**: `API_BASE_URL`, `MAX_RETRY_COUNT`

---

## 5. 데이터베이스 설계

### 5.1 ERD (Entity Relationship Diagram)

```mermaid
erDiagram
    User ||--o{ UserMedicine : "has"
    User ||--|| LifePattern : "has"
    User ||--o{ MedicationSchedule : "has"
    Medicine ||--o{ UserMedicine : "referenced by"
    Medicine ||--o{ MedicationSchedule : "scheduled in"
    UserMedicine ||--o{ MedicationSchedule : "generates"
    
    User {
        string id PK
        string email UK
        string name
        string password
        datetime createdAt
        datetime updatedAt
    }
    
    LifePattern {
        string id PK
        string userId FK
        string wakeTime
        string sleepTime
        string breakfastTime
        string lunchTime
        string dinnerTime
        string workStartTime
        string workEndTime
        boolean drivesOften
        boolean needsConcentration
        boolean shiftWork
        datetime createdAt
        datetime updatedAt
    }
    
    Medicine {
        string id PK
        string itemName
        string itemEngName
        string entpName
        string mainIngrName
        string efcyQesitm
        string useMethodQesitm
        string atpnWarnQesitm
        string depositMethodQesitm
        string sleepInducing
        string alertnessEffect
        string chronopharmacology
        datetime createdAt
        datetime updatedAt
    }
    
    UserMedicine {
        string id PK
        string userId FK
        string medicineId FK
        string dosage
        int frequency
        date startDate
        date endDate
        boolean isActive
        datetime createdAt
        datetime updatedAt
    }
    
    MedicationSchedule {
        string id PK
        string userId FK
        string userMedicineId FK
        string medicineId FK
        string timeSlot
        string recommendedTime
        string reason
        boolean isCompleted
        date scheduleDate
        datetime completedAt
        datetime createdAt
        datetime updatedAt
    }
```

### 5.2 Prisma Schema

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

// 사용자 모델
model User {
  id                   String               @id @default(cuid())
  email                String               @unique
  name                 String
  password             String
  emailVerified        DateTime?
  image                String?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  
  // Relations
  lifePattern          LifePattern?
  userMedicines        UserMedicine[]
  medicationSchedules  MedicationSchedule[]
  accounts             Account[]
  sessions             Session[]
  
  @@index([email])
  @@map("users")
}

// NextAuth.js Account 모델
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([provider, providerAccountId])
  @@map("accounts")
}

// NextAuth.js Session 모델
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

// 생활 패턴 모델
model LifePattern {
  id                  String   @id @default(cuid())
  userId              String   @unique
  wakeTime            String   // "07:00" 형식
  sleepTime           String   // "23:00" 형식
  breakfastTime       String?  // "08:00" 형식
  lunchTime           String?  // "12:00" 형식
  dinnerTime          String?  // "18:00" 형식
  workStartTime       String?  // "09:00" 형식
  workEndTime         String?  // "18:00" 형식
  drivesOften         Boolean  @default(false)
  needsConcentration  Boolean  @default(false)
  shiftWork           Boolean  @default(false)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("life_patterns")
}

// 약물 모델
model Medicine {
  id                    String               @id @default(cuid())
  itemName              String               // 품목명
  itemEngName           String?              // 영문 품목명
  entpName              String?              // 업체명
  mainIngrName          String?              // 주성분명
  efcyQesitm            String?              @db.Text // 효능효과
  useMethodQesitm       String?              @db.Text // 복용방법
  atpnWarnQesitm        String?              @db.Text // 주의사항 경고
  depositMethodQesitm   String?              @db.Text // 보관방법
  intrcQesitm           String?              @db.Text // 상호작용
  seQesitm              String?              @db.Text // 부작용
  
  // 복용 시간 관련 정보
  sleepInducing         String?              // 졸음 유발: "HIGH", "MODERATE", "LOW", "NONE"
  alertnessEffect       String?              // 각성 효과: "HIGH", "MODERATE", "LOW", "NONE"
  foodInteraction       String?              // 식사 관계: "EMPTY_STOMACH", "AFTER_MEAL", "ANYTIME"
  chronopharmacology    String?              @db.Text // 시간약리학 정보
  
  externalId            String?              // 식약처 API ID
  imageUrl              String?              // 약품 이미지
  
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  
  // Relations
  userMedicines         UserMedicine[]
  medicationSchedules   MedicationSchedule[]
  
  @@index([itemName])
  @@index([mainIngrName])
  @@map("medicines")
}

// 사용자 약물 모델
model UserMedicine {
  id                   String               @id @default(cuid())
  userId               String
  medicineId           String
  dosage               String               // "1정", "500mg"
  frequency            Int                  // 1일 복용 횟수
  startDate            DateTime             @default(now())
  endDate              DateTime?
  isActive             Boolean              @default(true)
  notes                String?              @db.Text
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  
  user                 User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  medicine             Medicine             @relation(fields: [medicineId], references: [id])
  medicationSchedules  MedicationSchedule[]
  
  @@index([userId])
  @@index([medicineId])
  @@map("user_medicines")
}

// 복용 스케줄 모델
model MedicationSchedule {
  id               String       @id @default(cuid())
  userId           String
  userMedicineId   String
  medicineId       String
  scheduleDate     DateTime     // 복용 날짜
  timeSlot         String       // "MORNING", "AFTERNOON", "EVENING", "BEDTIME"
  recommendedTime  String       // "08:00" 형식
  reason           String?      @db.Text // 추천 이유
  isCompleted      Boolean      @default(false)
  completedAt      DateTime?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userMedicine     UserMedicine @relation(fields: [userMedicineId], references: [id], onDelete: Cascade)
  medicine         Medicine     @relation(fields: [medicineId], references: [id])
  
  @@index([userId, scheduleDate])
  @@index([userMedicineId])
  @@map("medication_schedules")
}

// 검색 기록 모델 (선택사항)
model SearchHistory {
  id         String   @id @default(cuid())
  userId     String?
  query      String
  resultCount Int
  createdAt  DateTime @default(now())
  
  @@index([userId])
  @@map("search_history")
}
```

### 5.3 데이터베이스 마이그레이션

```bash
# 마이그레이션 생성
npx prisma migrate dev --name init

# 마이그레이션 적용 (프로덕션)
npx prisma migrate deploy

# Prisma Client 생성
npx prisma generate

# 데이터베이스 시드
npx prisma db seed
```

### 5.4 시드 데이터 예시

```typescript
// prisma/seed.ts
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  // 샘플 약물 데이터
  const medicines = [
    {
      itemName: '타이레놀정 500밀리그램',
      itemEngName: 'Tylenol 500mg Tablet',
      entpName: '한국얀센',
      mainIngrName: 'Acetaminophen',
      efcyQesitm: '두통, 치통, 월경통, 근육통 등의 통증 완화 및 발열 해소',
      useMethodQesitm: '성인: 1회 1~2정, 1일 3~4회 복용',
      sleepInducing: 'NONE',
      alertnessEffect: 'NONE',
      foodInteraction: 'ANYTIME',
      chronopharmacology: '증상 발생 시 복용. 특정 시간대 제약 없음.',
    },
    {
      itemName: '졸피뎀정 10밀리그램',
      itemEngName: 'Zolpidem 10mg',
      entpName: '삼성제약',
      mainIngrName: 'Zolpidem',
      efcyQesitm: '불면증 치료',
      useMethodQesitm: '취침 직전 복용',
      sleepInducing: 'HIGH',
      alertnessEffect: 'NONE',
      foodInteraction: 'EMPTY_STOMACH',
      chronopharmacology: '취침 30분 전 복용 권장. 수면 리듬과 직접 관련.',
    },
  ];

  for (const medicine of medicines) {
    await prisma.medicine.upsert({
      where: { itemName: medicine.itemName },
      update: {},
      create: medicine,
    });
  }

  // 테스트 사용자
  const hashedPassword = await bcrypt.hash('password123', 10);
  await prisma.user.upsert({
    where: { email: 'test@example.com' },
    update: {},
    create: {
      email: 'test@example.com',
      name: '테스트 사용자',
      password: hashedPassword,
    },
  });

  console.log('Seed completed!');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

---

## 6. API 설계

### 6.1 API 엔드포인트 목록

#### 인증 (Authentication)

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| POST | `/api/auth/register` | 회원가입 | No |
| POST | `/api/auth/login` | 로그인 | No |
| POST | `/api/auth/logout` | 로그아웃 | Yes |
| GET | `/api/auth/session` | 세션 조회 | Yes |

#### 약물 (Medicines)

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/api/medicines/search?q={query}` | 약물 검색 | No |
| GET | `/api/medicines/{id}` | 약물 상세 정보 | No |
| GET | `/api/medicines/external/search` | 식약처 API 프록시 | No |

#### 사용자 약물 (User Medicines)

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/api/user-medicines` | 내 약 목록 조회 | Yes |
| POST | `/api/user-medicines` | 내 약 추가 | Yes |
| GET | `/api/user-medicines/{id}` | 내 약 상세 | Yes |
| PATCH | `/api/user-medicines/{id}` | 내 약 수정 | Yes |
| DELETE | `/api/user-medicines/{id}` | 내 약 삭제 | Yes |

#### 복용 시간 추천 (Recommendations)

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| POST | `/api/recommendations` | 복용 시간 추천 생성 | Yes |
| GET | `/api/recommendations/{medicineId}` | 특정 약물 추천 조회 | Yes |

#### 생활 패턴 (Life Pattern)

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/api/patterns` | 생활 패턴 조회 | Yes |
| POST | `/api/patterns` | 생활 패턴 생성 | Yes |
| PATCH | `/api/patterns` | 생활 패턴 수정 | Yes |

#### 복용 스케줄 (Schedule)

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/api/schedule?date={date}` | 특정 날짜 스케줄 조회 | Yes |
| POST | `/api/schedule/{id}/complete` | 복용 완료 처리 | Yes |
| GET | `/api/schedule/stats` | 복용 통계 조회 | Yes |

### 6.2 API 구현 예시

#### 약물 검색 API

```typescript
// src/app/api/medicines/search/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q');
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    
    if (!query || query.length < 2) {
      return NextResponse.json(
        { error: '검색어는 2자 이상 입력해주세요.' },
        { status: 400 }
      );
    }
    
    const skip = (page - 1) * limit;
    
    const [medicines, total] = await Promise.all([
      prisma.medicine.findMany({
        where: {
          OR: [
            { itemName: { contains: query, mode: 'insensitive' } },
            { mainIngrName: { contains: query, mode: 'insensitive' } },
          ],
        },
        skip,
        take: limit,
        orderBy: { itemName: 'asc' },
      }),
      prisma.medicine.count({
        where: {
          OR: [
            { itemName: { contains: query, mode: 'insensitive' } },
            { mainIngrName: { contains: query, mode: 'insensitive' } },
          ],
        },
      }),
    ]);
    
    return NextResponse.json({
      medicines,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error) {
    console.error('Medicine search error:', error);
    return NextResponse.json(
      { error: '약물 검색 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

#### 복용 시간 추천 API

```typescript
// src/app/api/recommendations/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { generateRecommendation } from '@/services/recommendationService';

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }
    
    const body = await request.json();
    const { medicineId, userMedicineId } = body;
    
    // 약물 정보 조회
    const medicine = await prisma.medicine.findUnique({
      where: { id: medicineId },
    });
    
    if (!medicine) {
      return NextResponse.json(
        { error: '약물을 찾을 수 없습니다.' },
        { status: 404 }
      );
    }
    
    // 사용자 생활 패턴 조회
    const lifePattern = await prisma.lifePattern.findUnique({
      where: { userId: session.user.id },
    });
    
    // 추천 생성
    const recommendation = generateRecommendation(medicine, lifePattern);
    
    return NextResponse.json({ recommendation });
  } catch (error) {
    console.error('Recommendation error:', error);
    return NextResponse.json(
      { error: '추천 생성 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

#### 식약처 API 프록시

```typescript
// src/app/api/medicines/external/route.ts
import { NextRequest, NextResponse } from 'next/server';
import axios from 'axios';

const MFDS_API_URL = 'http://apis.data.go.kr/1471000/DrugPrdtPrmsnInfoService07/getDrugPrdtPrmsnInq07';
const SERVICE_KEY = process.env.MFDS_SERVICE_KEY;

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const itemName = searchParams.get('item_name');
    
    if (!itemName) {
      return NextResponse.json(
        { error: '약품명을 입력해주세요.' },
        { status: 400 }
      );
    }
    
    const response = await axios.get(MFDS_API_URL, {
      params: {
        serviceKey: SERVICE_KEY,
        item_name: itemName,
        numOfRows: 10,
        pageNo: 1,
        type: 'json',
      },
    });
    
    return NextResponse.json(response.data);
  } catch (error) {
    console.error('External API error:', error);
    return NextResponse.json(
      { error: '외부 API 호출 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

### 6.3 API Response 포맷

#### 성공 응답

```json
{
  "success": true,
  "data": {
    "id": "cm1a2b3c4d",
    "itemName": "타이레놀정 500밀리그램",
    "mainIngrName": "Acetaminophen",
    "entpName": "한국얀센"
  },
  "message": "조회 성공"
}
```

#### 에러 응답

```json
{
  "success": false,
  "error": {
    "code": "MEDICINE_NOT_FOUND",
    "message": "약물을 찾을 수 없습니다.",
    "details": {}
  }
}
```

### 6.4 에러 코드 정의

| Code | HTTP Status | Description |
|------|-------------|-------------|
| `UNAUTHORIZED` | 401 | 인증 필요 |
| `FORBIDDEN` | 403 | 권한 없음 |
| `NOT_FOUND` | 404 | 리소스 없음 |
| `VALIDATION_ERROR` | 400 | 입력 검증 실패 |
| `INTERNAL_ERROR` | 500 | 서버 오류 |
| `EXTERNAL_API_ERROR` | 502 | 외부 API 오류 |

---

## 7. 인증 및 보안

### 7.1 NextAuth.js 설정

```typescript
// src/lib/auth.ts
import { NextAuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from './prisma';
import bcrypt from 'bcryptjs';

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('이메일과 비밀번호를 입력해주세요.');
        }
        
        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });
        
        if (!user || !user.password) {
          throw new Error('사용자를 찾을 수 없습니다.');
        }
        
        const isValid = await bcrypt.compare(
          credentials.password,
          user.password
        );
        
        if (!isValid) {
          throw new Error('비밀번호가 일치하지 않습니다.');
        }
        
        return {
          id: user.id,
          email: user.email,
          name: user.name,
        };
      },
    }),
  ],
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  pages: {
    signIn: '/login',
    signOut: '/logout',
    error: '/auth/error',
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
      }
      return session;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};
```

### 7.2 인증 미들웨어

```typescript
// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getToken } from 'next-auth/jwt';

export async function middleware(request: NextRequest) {
  const token = await getToken({
    req: request,
    secret: process.env.NEXTAUTH_SECRET,
  });
  
  const isAuthPage = request.nextUrl.pathname.startsWith('/login') ||
                     request.nextUrl.pathname.startsWith('/register');
  
  const isProtectedPage = request.nextUrl.pathname.startsWith('/dashboard') ||
                          request.nextUrl.pathname.startsWith('/medicines') ||
                          request.nextUrl.pathname.startsWith('/schedule');
  
  // 로그인 상태에서 인증 페이지 접근 시 대시보드로 리다이렉트
  if (isAuthPage && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }
  
  // 비로그인 상태에서 보호된 페이지 접근 시 로그인 페이지로 리다이렉트
  if (isProtectedPage && !token) {
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('callbackUrl', request.nextUrl.pathname);
    return NextResponse.redirect(loginUrl);
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/medicines/:path*',
    '/schedule/:path*',
    '/settings/:path*',
    '/login',
    '/register',
  ],
};
```

### 7.3 환경 변수 관리

```bash
# .env.local
# Database
POSTGRES_URL="postgres://..."
POSTGRES_PRISMA_URL="postgres://..."
POSTGRES_URL_NON_POOLING="postgres://..."

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-secret-key-here"

# External APIs
MFDS_SERVICE_KEY="your-mfds-api-key"

# Optional
NODE_ENV="development"
```

```bash
# .env.example (Git에 커밋)
# Database
POSTGRES_URL="postgres://username:password@host:5432/database"
POSTGRES_PRISMA_URL="postgres://username:password@host:5432/database?pgbouncer=true"
POSTGRES_URL_NON_POOLING="postgres://username:password@host:5432/database"

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="generate-with: openssl rand -base64 32"

# External APIs
MFDS_SERVICE_KEY="your-api-key-from-data.go.kr"
```

### 7.4 보안 Best Practices

#### API Route 보호

```typescript
// src/lib/apiAuth.ts
import { getServerSession } from 'next-auth';
import { authOptions } from './auth';
import { NextResponse } from 'next/server';

export async function requireAuth() {
  const session = await getServerSession(authOptions);
  
  if (!session?.user) {
    throw new Error('Unauthorized');
  }
  
  return session;
}

// 사용 예시
export async function GET(request: NextRequest) {
  try {
    const session = await requireAuth();
    // ... API 로직
  } catch (error) {
    return NextResponse.json(
      { error: '로그인이 필요합니다.' },
      { status: 401 }
    );
  }
}
```

#### 비밀번호 해싱

```typescript
// src/services/userService.ts
import bcrypt from 'bcryptjs';

export async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

export async function verifyPassword(
  password: string,
  hashedPassword: string
): Promise<boolean> {
  return bcrypt.compare(password, hashedPassword);
}
```

#### Rate Limiting (선택사항)

```typescript
// src/lib/rateLimit.ts
import { NextRequest } from 'next/server';

const rateLimit = new Map<string, { count: number; resetAt: number }>();

export function checkRateLimit(
  request: NextRequest,
  limit: number = 10,
  windowMs: number = 60000
): boolean {
  const ip = request.ip || 'anonymous';
  const now = Date.now();
  const record = rateLimit.get(ip);
  
  if (!record || now > record.resetAt) {
    rateLimit.set(ip, { count: 1, resetAt: now + windowMs });
    return true;
  }
  
  if (record.count >= limit) {
    return false;
  }
  
  record.count++;
  return true;
}
```

---

## 8. 상태 관리

### 8.1 Zustand Store 구성

#### 인증 스토어

```typescript
// src/store/authStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: string;
  email: string;
  name: string;
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  setUser: (user: User | null) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      isAuthenticated: false,
      setUser: (user) => set({ user, isAuthenticated: !!user }),
      logout: () => set({ user: null, isAuthenticated: false }),
    }),
    {
      name: 'auth-storage',
    }
  )
);
```

#### 약물 스토어

```typescript
// src/store/medicineStore.ts
import { create } from 'zustand';
import { Medicine } from '@/types/medicine';

interface MedicineState {
  medicines: Medicine[];
  selectedMedicine: Medicine | null;
  searchQuery: string;
  isLoading: boolean;
  error: string | null;
  
  setMedicines: (medicines: Medicine[]) => void;
  setSelectedMedicine: (medicine: Medicine | null) => void;
  setSearchQuery: (query: string) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  clearSearch: () => void;
}

export const useMedicineStore = create<MedicineState>((set) => ({
  medicines: [],
  selectedMedicine: null,
  searchQuery: '',
  isLoading: false,
  error: null,
  
  setMedicines: (medicines) => set({ medicines }),
  setSelectedMedicine: (medicine) => set({ selectedMedicine: medicine }),
  setSearchQuery: (query) => set({ searchQuery: query }),
  setLoading: (isLoading) => set({ isLoading }),
  setError: (error) => set({ error }),
  clearSearch: () => set({ searchQuery: '', medicines: [], error: null }),
}));
```

#### UI 스토어

```typescript
// src/store/uiStore.ts
import { create } from 'zustand';

interface UIState {
  sidebarOpen: boolean;
  modalOpen: boolean;
  modalType: string | null;
  toast: { message: string; type: 'success' | 'error' | 'info' } | null;
  
  toggleSidebar: () => void;
  openModal: (type: string) => void;
  closeModal: () => void;
  showToast: (message: string, type: 'success' | 'error' | 'info') => void;
  hideToast: () => void;
}

export const useUIStore = create<UIState>((set) => ({
  sidebarOpen: false,
  modalOpen: false,
  modalType: null,
  toast: null,
  
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
  openModal: (type) => set({ modalOpen: true, modalType: type }),
  closeModal: () => set({ modalOpen: false, modalType: null }),
  showToast: (message, type) => set({ toast: { message, type } }),
  hideToast: () => set({ toast: null }),
}));
```

### 8.2 커스텀 훅

```typescript
// src/hooks/useMedicine.ts
import { useCallback } from 'react';
import { useMedicineStore } from '@/store/medicineStore';
import axios from 'axios';

export function useMedicine() {
  const {
    medicines,
    selectedMedicine,
    searchQuery,
    isLoading,
    error,
    setMedicines,
    setSelectedMedicine,
    setSearchQuery,
    setLoading,
    setError,
    clearSearch,
  } = useMedicineStore();
  
  const searchMedicines = useCallback(async (query: string) => {
    if (!query || query.length < 2) {
      setError('검색어는 2자 이상 입력해주세요.');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.get(`/api/medicines/search`, {
        params: { q: query },
      });
      
      setMedicines(response.data.medicines);
      setSearchQuery(query);
    } catch (err: any) {
      setError(err.response?.data?.error || '검색 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  }, [setMedicines, setSearchQuery, setLoading, setError]);
  
  const getMedicineDetail = useCallback(async (id: string) => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await axios.get(`/api/medicines/${id}`);
      setSelectedMedicine(response.data);
    } catch (err: any) {
      setError(err.response?.data?.error || '약물 정보를 불러올 수 없습니다.');
    } finally {
      setLoading(false);
    }
  }, [setSelectedMedicine, setLoading, setError]);
  
  return {
    medicines,
    selectedMedicine,
    searchQuery,
    isLoading,
    error,
    searchMedicines,
    getMedicineDetail,
    clearSearch,
  };
}
```

---

## 9. 스타일링 시스템

### 9.1 Tailwind CSS 설정

```typescript
// tailwind.config.ts
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: '#7FA99B',
          hover: '#6B8E7F',
          pressed: '#587262',
          light: '#E8F0EC',
          pale: '#D4E5DC',
        },
        secondary: {
          DEFAULT: '#F8F9F6',
          border: '#D4D9D0',
        },
        accent: {
          DEFAULT: '#E9B872',
          hover: '#D9A560',
          light: '#FEF8E7',
        },
        success: {
          DEFAULT: '#9CAF88',
          light: '#E3F0E8',
          dark: '#7A8F6E',
        },
        warning: {
          DEFAULT: '#E8A87C',
          light: '#FEF8E7',
          dark: '#D48A5A',
        },
        danger: {
          DEFAULT: '#D48A88',
          light: '#FADBD8',
          dark: '#C67876',
        },
        info: {
          DEFAULT: '#8FA9C9',
          light: '#E8EDF5',
          dark: '#6B8AAF',
        },
        neutral: {
          50: '#F9FAFB',
          100: '#F3F4F6',
          200: '#E5E7EB',
          300: '#D1D5DB',
          400: '#9CA3AF',
          500: '#6B7280',
          600: '#4B5563',
          700: '#374151',
          800: '#1F2937',
          900: '#111827',
        },
      },
      fontFamily: {
        sans: ['var(--font-pretendard)', 'system-ui', 'sans-serif'],
      },
      fontSize: {
        'xs': '12px',
        'sm': '14px',
        'base': '16px',
        'lg': '18px',
        'xl': '20px',
        '2xl': '24px',
        '3xl': '32px',
        '4xl': '48px',
      },
      spacing: {
        '18': '4.5rem',
        '88': '22rem',
        '100': '25rem',
      },
      borderRadius: {
        'sm': '8px',
        'md': '12px',
        'lg': '16px',
        'xl': '20px',
        '2xl': '24px',
      },
      boxShadow: {
        'sm': '0 1px 3px rgba(0, 0, 0, 0.1)',
        'md': '0 4px 12px rgba(0, 0, 0, 0.1)',
        'lg': '0 8px 24px rgba(0, 0, 0, 0.12)',
        'xl': '0 20px 25px rgba(0, 0, 0, 0.15)',
      },
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
  ],
};

export default config;
```

### 9.2 글로벌 스타일

```css
/* src/app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --font-pretendard: 'Pretendard Variable', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  }
  
  * {
    @apply border-neutral-200;
  }
  
  body {
    @apply bg-white text-neutral-800 font-sans;
  }
  
  h1, h2, h3, h4, h5, h6 {
    @apply font-bold text-neutral-900;
  }
}

@layer components {
  .btn {
    @apply px-8 py-3.5 rounded-lg font-semibold transition-all duration-200;
  }
  
  .btn-primary {
    @apply btn bg-primary text-white hover:bg-primary-hover active:bg-primary-pressed;
  }
  
  .btn-secondary {
    @apply btn bg-white text-primary border-2 border-primary hover:bg-primary-light;
  }
  
  .btn-danger {
    @apply btn bg-danger text-white hover:bg-danger-dark;
  }
  
  .card {
    @apply bg-white border border-neutral-200 rounded-xl p-6 transition-all duration-250;
  }
  
  .card-hover {
    @apply card hover:shadow-lg hover:-translate-y-0.5;
  }
  
  .input {
    @apply w-full h-12 px-4 border border-neutral-300 rounded-lg text-base;
    @apply focus:outline-none focus:border-primary focus:ring-4 focus:ring-primary/10;
  }
  
  .alert {
    @apply p-4 rounded-lg flex items-start gap-3 mb-6;
  }
  
  .alert-info {
    @apply alert bg-primary-light border border-primary text-neutral-800;
  }
  
  .alert-warning {
    @apply alert bg-warning-light border border-warning text-yellow-800;
  }
  
  .alert-danger {
    @apply alert bg-danger-light border-2 border-danger text-red-800;
  }
  
  .alert-success {
    @apply alert bg-success-light border border-success text-green-800;
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}
```

### 9.3 컴포넌트 스타일 예시

```typescript
// src/components/ui/Button.tsx
import { ButtonHTMLAttributes, forwardRef } from 'react';
import { cn } from '@/lib/utils';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'primary', size = 'md', isLoading, children, disabled, ...props }, ref) => {
    return (
      <button
        ref={ref}
        className={cn(
          'btn',
          {
            'btn-primary': variant === 'primary',
            'btn-secondary': variant === 'secondary',
            'btn-danger': variant === 'danger',
            'btn-sm': size === 'sm',
            'btn-lg': size === 'lg',
            'opacity-50 cursor-not-allowed': disabled || isLoading,
          },
          className
        )}
        disabled={disabled || isLoading}
        {...props}
      >
        {isLoading && <span className="animate-spin mr-2">⏳</span>}
        {children}
      </button>
    );
  }
);

Button.displayName = 'Button';
```

---

## 10. 배포 전략

### 10.1 Vercel 배포 설정

```json
// vercel.json
{
  "buildCommand": "prisma generate && next build",
  "devCommand": "next dev",
  "installCommand": "npm install",
  "framework": "nextjs",
  "regions": ["icn1"],
  "env": {
    "POSTGRES_URL": "@postgres-url",
    "POSTGRES_PRISMA_URL": "@postgres-prisma-url",
    "POSTGRES_URL_NON_POOLING": "@postgres-url-non-pooling",
    "NEXTAUTH_SECRET": "@nextauth-secret",
    "MFDS_SERVICE_KEY": "@mfds-service-key"
  }
}
```

### 10.2 환경별 설정

#### Development (로컬)
```bash
# .env.local
NODE_ENV=development
NEXTAUTH_URL=http://localhost:3000
```

#### Preview (Vercel Preview)
- PR마다 자동 생성
- Preview URL 제공
- 프로덕션과 동일한 환경

#### Production (Vercel Production)
```bash
# Vercel Dashboard에서 설정
NODE_ENV=production
NEXTAUTH_URL=https://yourdomain.com
```

### 10.3 CI/CD 파이프라인

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run lint

  type-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run type-check

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npx prisma generate
      - run: npm run build
```

### 10.4 배포 체크리스트

#### 초기 배포 전
- [ ] Vercel 프로젝트 생성
- [ ] Vercel Postgres 데이터베이스 생성
- [ ] 환경 변수 설정 (Vercel Dashboard)
- [ ] 도메인 연결 (선택사항)
- [ ] Prisma 마이그레이션 실행
- [ ] 시드 데이터 삽입

#### 배포 후
- [ ] Health check 확인
- [ ] API 엔드포인트 테스트
- [ ] 인증 플로우 테스트
- [ ] 반응형 디자인 확인
- [ ] 성능 모니터링 설정

---

## 11. 성능 최적화

### 11.1 Next.js 최적화

#### 이미지 최적화

```typescript
// src/components/OptimizedImage.tsx
import Image from 'next/image';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
}

export function OptimizedImage({ src, alt, width, height }: OptimizedImageProps) {
  return (
    <Image
      src={src}
      alt={alt}
      width={width}
      height={height}
      loading="lazy"
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRg..."
    />
  );
}
```

#### 동적 임포트

```typescript
// src/app/dashboard/page.tsx
import dynamic from 'next/dynamic';

const HeavyChart = dynamic(() => import('@/components/HeavyChart'), {
  loading: () => <div>Loading...</div>,
  ssr: false,
});

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <HeavyChart />
    </div>
  );
}
```

#### Server Components 활용

```typescript
// Server Component (기본)
async function MedicineList() {
  const medicines = await prisma.medicine.findMany();
  
  return (
    <div>
      {medicines.map((medicine) => (
        <MedicineCard key={medicine.id} medicine={medicine} />
      ))}
    </div>
  );
}

// Client Component (필요시에만)
'use client';

function InteractiveMedicineCard() {
  const [liked, setLiked] = useState(false);
  
  return (
    <button onClick={() => setLiked(!liked)}>
      {liked ? '❤️' : '🤍'}
    </button>
  );
}
```

### 11.2 데이터베이스 최적화

#### Connection Pooling

```typescript
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

#### 쿼리 최적화

```typescript
// Bad: N+1 문제
const users = await prisma.user.findMany();
for (const user of users) {
  const medicines = await prisma.userMedicine.findMany({
    where: { userId: user.id },
  });
}

// Good: Include 사용
const users = await prisma.user.findMany({
  include: {
    userMedicines: {
      include: {
        medicine: true,
      },
    },
  },
});
```

### 11.3 캐싱 전략

#### SWR 설정

```typescript
// src/lib/swr-config.ts
import { SWRConfiguration } from 'swr';

export const swrConfig: SWRConfiguration = {
  revalidateOnFocus: false,
  revalidateOnReconnect: true,
  dedupingInterval: 5000,
  errorRetryCount: 3,
  fetcher: (url: string) => fetch(url).then((res) => res.json()),
};
```

#### API Route 캐싱

```typescript
// src/app/api/medicines/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';

export const revalidate = 3600; // 1시간 캐시

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const medicine = await prisma.medicine.findUnique({
    where: { id: params.id },
  });
  
  return NextResponse.json(medicine, {
    headers: {
      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
    },
  });
}
```

---

## 12. 개발 환경 설정

### 12.1 필수 도구 설치

#### 1. Node.js 설치
```bash
# Node.js 20.x LTS 권장
# https://nodejs.org/ 에서 다운로드
node --version  # v20.x.x 확인
npm --version   # v10.x.x 확인
```

#### 2. Git 설치
```bash
# https://git-scm.com/ 에서 다운로드
git --version
```

#### 3. VS Code 설치 (권장 에디터)
- https://code.visualstudio.com/

#### 4. VS Code 확장 프로그램
- ESLint
- Prettier - Code formatter
- Tailwind CSS IntelliSense
- Prisma
- GitLens

### 12.2 프로젝트 초기화

```bash
# 1. Next.js 프로젝트 생성
npx create-next-app@latest meditime --typescript --tailwind --app --src-dir

# 2. 프로젝트 디렉토리 이동
cd meditime

# 3. 추가 패키지 설치
npm install @prisma/client prisma
npm install next-auth @auth/prisma-adapter
npm install zustand
npm install axios swr
npm install react-hook-form zod @hookform/resolvers
npm install date-fns
npm install bcryptjs
npm install @radix-ui/react-dialog @radix-ui/react-dropdown-menu
npm install @heroicons/react

# 4. 개발 의존성 설치
npm install -D @types/node @types/react @types/bcryptjs
npm install -D eslint prettier eslint-config-prettier
npm install -D husky lint-staged

# 5. Prisma 초기화
npx prisma init

# 6. Git 초기화
git init
git add .
git commit -m "Initial commit"
```

### 12.3 설정 파일 생성

#### package.json scripts

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "prisma generate && next build",
    "start": "next start",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "format": "prettier --write \"**/*.{ts,tsx,md,json}\"",
    "type-check": "tsc --noEmit",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts",
    "prepare": "husky install"
  }
}
```

#### .eslintrc.json

```json
{
  "extends": [
    "next/core-web-vitals",
    "prettier"
  ],
  "rules": {
    "no-console": ["warn", { "allow": ["warn", "error"] }],
    "no-unused-vars": "off",
    "@typescript-eslint/no-unused-vars": ["warn", { "argsIgnorePattern": "^_" }],
    "react/no-unescaped-entities": "off"
  }
}
```

#### .prettierrc

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}
```

#### .gitignore

```
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# prisma
prisma/migrations/
```

---

## 13. 개발 워크플로우

### 13.1 브랜치 전략

```
main (프로덕션)
├── develop (개발)
│   ├── feature/user-auth
│   ├── feature/medicine-search
│   └── feature/recommendation-engine
└── hotfix/critical-bug
```

### 13.2 개발 프로세스

#### 1. 새 기능 개발

```bash
# develop 브랜치에서 feature 브랜치 생성
git checkout develop
git pull origin develop
git checkout -b feature/medicine-search

# 개발 진행...

# 커밋
git add .
git commit -m "feat: add medicine search functionality"

# Push
git push origin feature/medicine-search

# GitHub에서 Pull Request 생성
# develop <- feature/medicine-search
```

#### 2. 커밋 메시지 규칙

```
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정
style: 코드 포매팅
refactor: 코드 리팩토링
test: 테스트 코드
chore: 빌드 설정 등

예시:
feat: add medicine recommendation API
fix: resolve authentication timeout issue
docs: update API documentation
```

#### 3. 코드 리뷰 체크리스트

- [ ] 코드가 요구사항을 충족하는가?
- [ ] 테스트가 통과하는가?
- [ ] 타입 에러가 없는가?
- [ ] 린트 에러가 없는가?
- [ ] 주석이 명확한가?
- [ ] 보안 문제가 없는가?
- [ ] 성능 이슈가 없는가?

### 13.3 로컬 개발 환경 실행

```bash
# 1. 데이터베이스 설정
npm run db:push

# 2. 시드 데이터 삽입
npm run db:seed

# 3. 개발 서버 실행
npm run dev

# 4. Prisma Studio 실행 (DB GUI)
npm run db:studio

# 브라우저에서 http://localhost:3000 접속
```

---

## 14. 트러블슈팅

### 14.1 일반적인 문제

#### Prisma Client 에러

```bash
# 문제: Prisma Client가 생성되지 않음
# 해결:
npx prisma generate
```

#### 데이터베이스 연결 실패

```bash
# 문제: Database connection failed
# 해결: .env.local 파일 확인
# POSTGRES_URL이 올바른지 확인
# Vercel Dashboard에서 Connection String 재확인
```

#### NextAuth 세션 에러

```bash
# 문제: Session not working
# 해결:
# 1. NEXTAUTH_SECRET 환경 변수 설정 확인
openssl rand -base64 32

# 2. NEXTAUTH_URL 확인
# 로컬: http://localhost:3000
# 프로덕션: https://yourdomain.com
```

#### 빌드 에러

```bash
# 문제: Type error during build
# 해결:
npm run type-check
# 타입 에러 수정 후 다시 빌드
```

### 14.2 성능 문제

#### 느린 쿼리

```typescript
// Prisma 쿼리 로깅 활성화
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
});

// 느린 쿼리 최적화:
// 1. 인덱스 추가
// 2. Include 대신 Select 사용
// 3. Pagination 구현
```

#### 큰 번들 크기

```bash
# Bundle analyzer 설치
npm install -D @next/bundle-analyzer

# next.config.js에 추가
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

# 분석 실행
ANALYZE=true npm run build
```

### 14.3 배포 문제

#### Vercel 빌드 실패

```bash
# 로그 확인
vercel logs [deployment-url]

# 자주 발생하는 원인:
# 1. 환경 변수 누락
# 2. Prisma 마이그레이션 누락
# 3. TypeScript 에러

# 해결:
# Vercel Dashboard에서 환경 변수 확인
# Build Command 확인: prisma generate && next build
```

#### API Rate Limit

```typescript
// 식약처 API 호출 제한 처리
const cache = new Map();

async function fetchWithCache(url: string) {
  if (cache.has(url)) {
    return cache.get(url);
  }
  
  const response = await fetch(url);
  const data = await response.json();
  cache.set(url, data);
  
  setTimeout(() => cache.delete(url), 3600000); // 1시간 후 삭제
  
  return data;
}
```

---

## 15. 추가 리소스

### 15.1 공식 문서

- [Next.js Documentation](https://nextjs.org/docs)
- [React Documentation](https://react.dev)
- [TypeScript Documentation](https://www.typescriptlang.org/docs)
- [Prisma Documentation](https://www.prisma.io/docs)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [NextAuth.js Documentation](https://next-auth.js.org)
- [Zustand Documentation](https://docs.pmnd.rs/zustand)

### 15.2 유용한 도구

- [Vercel Dashboard](https://vercel.com/dashboard)
- [Prisma Studio](https://www.prisma.io/studio)
- [공공데이터 포털](https://www.data.go.kr)
- [Can I Use](https://caniuse.com) - 브라우저 호환성
- [Bundle Phobia](https://bundlephobia.com) - 패키지 크기 확인

### 15.3 커뮤니티

- [Next.js Discord](https://discord.gg/nextjs)
- [React Korea Facebook](https://www.facebook.com/groups/react.ko)
- [Stack Overflow](https://stackoverflow.com/questions/tagged/next.js)

---

## 부록

### A. TypeScript 타입 정의 예시

```typescript
// src/types/index.ts
export interface Medicine {
  id: string;
  itemName: string;
  itemEngName?: string;
  entpName?: string;
  mainIngrName?: string;
  efcyQesitm?: string;
  useMethodQesitm?: string;
  sleepInducing?: 'HIGH' | 'MODERATE' | 'LOW' | 'NONE';
  alertnessEffect?: 'HIGH' | 'MODERATE' | 'LOW' | 'NONE';
  foodInteraction?: 'EMPTY_STOMACH' | 'AFTER_MEAL' | 'ANYTIME';
  chronopharmacology?: string;
}

export interface UserMedicine {
  id: string;
  userId: string;
  medicineId: string;
  medicine: Medicine;
  dosage: string;
  frequency: number;
  startDate: Date;
  endDate?: Date;
  isActive: boolean;
}

export interface LifePattern {
  id: string;
  userId: string;
  wakeTime: string;
  sleepTime: string;
  breakfastTime?: string;
  lunchTime?: string;
  dinnerTime?: string;
  workStartTime?: string;
  workEndTime?: string;
  drivesOften: boolean;
  needsConcentration: boolean;
  shiftWork: boolean;
}

export interface Recommendation {
  timeSlot: 'MORNING' | 'AFTERNOON' | 'EVENING' | 'BEDTIME';
  recommendedTime: string;
  reason: string;
  warnings?: string[];
  considerations?: string[];
}
```

### B. 환경 변수 전체 목록

```bash
# Database
POSTGRES_URL=                       # Pooling connection string
POSTGRES_PRISMA_URL=                # Prisma connection string
POSTGRES_URL_NON_POOLING=           # Non-pooling connection string

# Authentication
NEXTAUTH_URL=                       # App URL
NEXTAUTH_SECRET=                    # Random secret key

# External APIs
MFDS_SERVICE_KEY=                   # 식약처 API 키

# Optional
NODE_ENV=                           # development | production
ANALYZE=                            # Bundle analyzer flag
```

---

**문서 버전**: 1.0  
**최종 수정일**: 2026년 1월 22일  
**작성자**: 개발팀  
**라이선스**: MIT

---

이 문서는 프로젝트의 성장과 함께 지속적으로 업데이트됩니다.
